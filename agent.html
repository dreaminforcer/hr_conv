<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ElevenLabs Conversational Agent</title>
</head>
<body>
  <h1>🎙️ Voice Chat with ElevenLabs Agent</h1>
  <p>Status: <span id="status">Disconnected</span></p>
  <button id="toggleBtn">Start Conversation</button>

  <script>
    const AGENT_ID = "sKApodJaLWdr6Xo5mslm"; // ← ВСТАВЬ свой agent_id
    const API_KEY = "sk_390b4884aebd3805236761ad470dda7bc5fe8a57fba0c96e";   // ← ВСТАВЬ свой API ключ

    const statusEl = document.getElementById("status");
    const toggleBtn = document.getElementById("toggleBtn");

    let socket;
    let mediaRecorder;
    let isRecording = false;
    let isConnected = false;

    async function getSignedUrl() {
      console.log("[Step 1] Запрашиваем signed URL...");
      try {
        const res = await fetch(
          `https://api.elevenlabs.io/v1/convai/conversation/get_signed_url?agent_id=${AGENT_ID}`,
          {
            method: "GET",
            headers: {
              "xi-api-key": API_KEY
            }
          }
        );

        if (!res.ok) {
          console.error("❌ Не удалось получить signed URL:", res.status, await res.text());
          return;
        }

        const data = await res.json();
        console.log("[Step 1] ✅ Signed URL получен:", data.signed_url);
        return data.signed_url;
      } catch (err) {
        console.error("❌ Ошибка при получении signed URL:", err);
      }
    }

    async function connectToAgent() {
      const signedUrl = await getSignedUrl();
      if (!signedUrl) {
        statusEl.textContent = "Ошибка при получении signed URL";
        return;
      }

      console.log("[Step 2] Подключаемся к WebSocket...");
      socket = new WebSocket(signedUrl);

      socket.onopen = () => {
        console.log("[Step 2] ✅ WebSocket соединение открыто.");
        statusEl.textContent = "Connected. Listening...";
        isConnected = true;
        toggleBtn.textContent = "Stop Conversation";
        startMicrophone();
      };

if (msg.audio) {
  console.log("🔉 Получен raw PCM audio. Пробуем воспроизвести...");

  try {
    const audioBuffer = Uint8Array.from(atob(msg.audio), c => c.charCodeAt(0)).buffer;

    const pcmData = new DataView(audioBuffer);
    const samples = new Float32Array(audioBuffer.byteLength / 2);

    // Преобразуем 16-bit PCM -> Float32
    for (let i = 0; i < samples.length; i++) {
      const s = pcmData.getInt16(i * 2, true); // Little endian
      samples[i] = s / 32768;
    }

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const sampleRate = 16000; // как в metadata
    const audioBufferObj = audioContext.createBuffer(1, samples.length, sampleRate);
    audioBufferObj.getChannelData(0).set(samples);

    const source = audioContext.createBufferSource();
    source.buffer = audioBufferObj;
    source.connect(audioContext.destination);
    source.start();

    console.log("✅ PCM декодировано и воспроизведено.");
  } catch (e) {
    console.error("❌ Ошибка при декодировании raw PCM:", e);
  }
};


      socket.onerror = (err) => {
        console.error("❌ WebSocket ошибка:", err);
        statusEl.textContent = "WebSocket error.";
      };

      socket.onclose = () => {
        console.warn("⚠️ WebSocket соединение закрыто.");
        statusEl.textContent = "Disconnected.";
        isConnected = false;
        toggleBtn.textContent = "Start Conversation";
      };
    }

    async function startMicrophone() {
      console.log("[Step 4] Запрашиваем доступ к микрофону...");
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        console.log("✅ Микрофон доступен.");

        mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
        let audioChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          console.log("🎤 Получен аудио фрагмент.");
          audioChunks.push(event.data);
        };

        mediaRecorder.onstop = async () => {
          console.log("⏹️ Остановка записи, отправляем аудио агенту...");

          const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
          audioChunks = [];

          const arrayBuffer = await audioBlob.arrayBuffer();
          const base64Audio = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));

          if (socket && socket.readyState === WebSocket.OPEN) {
            console.log("📤 Отправка аудио агенту...");
            socket.send(JSON.stringify({ audio: base64Audio }));
          } else {
            console.warn("⚠️ Невозможно отправить аудио: WebSocket закрыт.");
          }

          if (isRecording) {
            console.log("🔁 Продолжаем запись...");
            mediaRecorder.start();
            setTimeout(() => mediaRecorder.stop(), 2000);
          }
        };

        isRecording = true;
        console.log("▶️ Запускаем первую запись...");
        mediaRecorder.start();
        setTimeout(() => mediaRecorder.stop(), 2000);
      } catch (e) {
        console.error("❌ Ошибка доступа к микрофону:", e);
        statusEl.textContent = "Microphone error.";
      }
    }

    function stopConversation() {
      console.log("[Step 5] Остановка разговора...");
      isRecording = false;

      if (mediaRecorder && mediaRecorder.state !== "inactive") {
        console.log("⏹️ Останавливаем запись.");
        mediaRecorder.stop();
      }

      if (socket && socket.readyState === WebSocket.OPEN) {
        console.log("❌ Закрываем WebSocket...");
        socket.close();
      }

      statusEl.textContent = "Disconnected.";
      toggleBtn.textContent = "Start Conversation";
      isConnected = false;
    }

    toggleBtn.addEventListener("click", () => {
      if (!isConnected) {
        console.log("🔄 Кнопка: Начать разговор");
        connectToAgent();
      } else {
        console.log("🔄 Кнопка: Остановить разговор");
        stopConversation();
      }
    });
  </script>
</body>
</html>
